# Wiley Widget Development Guidelines - Python Tooling

## ğŸ Python-First Development Environment

This project uses a comprehensive Python-based tooling ecosystem that has replaced legacy PowerShell scripts for better cross-platform support, maintainability, and testing capabilities.

## ğŸš€ Core Development Workflow

### Development Startup
**Use**: `python scripts/dev-start.py` or VS Code task "dev-start"
- Cleans orphaned .NET processes
- Performs build hygiene (`dotnet clean`)
- Applies Azure performance optimizations
- Launches `dotnet watch` with monitoring

### Environment Management
**Use**: `python scripts/load-env.py`
- Loads configuration from `.env` file
- Resolves Azure Key Vault references
- Validates Azure connectivity
- Masks sensitive data in logs

**Commands**:
```bash
python scripts/load-env.py              # Load environment
python scripts/load-env.py --status     # Check status
python scripts/load-env.py --test-connections  # Test Azure
```

### Azure Setup
**Use**: `python scripts/azure-setup.py`
- Configures Azure CLI with proper defaults
- Sets up target subscription
- Tests Azure resource access

**Commands**:
```bash
python scripts/azure-setup.py                    # Full setup
python scripts/azure-setup.py --test-connection  # Test only
```

### Process Cleanup
**Use**: `python scripts/cleanup-dotnet.py`
- Safely removes orphaned .NET processes
- Cleans build artifacts
- Interactive confirmation mode

**Commands**:
```bash
python scripts/cleanup-dotnet.py        # Interactive cleanup
python scripts/cleanup-dotnet.py --force # Force cleanup (CI/CD)
```

## ğŸ§ª Testing Framework

### Test Execution
**Use**: pytest with comprehensive test suite
```bash
# Install dependencies
pip install -r requirements-test.txt

# Run tests
pytest                          # All tests
pytest -m "unit"               # Fast unit tests only
pytest -m "integration"        # Integration tests
pytest -m "azure"              # Azure-dependent tests
pytest --cov=scripts           # With coverage
pytest -n auto                 # Parallel execution
```

### Test Structure
- **Unit tests**: Fast, isolated function testing
- **Integration tests**: Cross-component testing
- **Azure tests**: Cloud resource testing
- **UI tests**: Interface testing

## ğŸ“‹ VS Code Integration

### Available Tasks
- `dev-start`: Main development startup
- `cleanup-dotnet`: Process cleanup
- `load-env`: Environment loading
- `azure-setup`: Azure configuration
- `azure-test-connection`: Azure connectivity testing
- `test-fast`: Quick unit tests

### Recommended Workflow
1. **Start**: Run "dev-start" task
2. **Develop**: Make changes with `dotnet watch` running
3. **Test**: Run "test-fast" task for quick feedback
4. **Clean**: Run "cleanup-dotnet" when done

## ğŸ”§ Development Best Practices

### Python Script Usage
- **Always use Python scripts** over PowerShell equivalents
- **Test scripts** before committing changes
- **Use VS Code tasks** for consistent execution
- **Check script output** for proper error handling

### PowerShell Script Standards
- **Use Write-Output** instead of Write-Host for pipeline-compatible output
- **Use Write-Information** for informational messages with -InformationAction parameter
- **Use Write-Verbose** for detailed diagnostic information
- **Avoid Write-Host** for new code - it doesn't write to the pipeline

### Environment Setup
- **Load environment first**: `python scripts/load-env.py`
- **Test connections**: `python scripts/load-env.py --test-connections`
- **Validate Azure setup**: `python scripts/azure-setup.py --test-connection`

### Testing Strategy
- **Run unit tests** before committing
- **Use coverage reports** to identify gaps
- **Test Azure features** with proper mocking
- **Parallel execution** for faster feedback

## ğŸ¯ **Technology Stack Reality Check**

### Primary Development Languages
- **C#/.NET**: Core application (WPF with Syncfusion)
- **Python**: Build tooling, testing, automation scripts
- **PowerShell**: Legacy scripts, Windows-specific operations

### Development Workflow Strategy
1. **New Scripts**: Prefer Python for cross-platform compatibility
2. **Windows-Specific**: Use PowerShell only when Python cannot provide equivalent functionality
3. **Migration Path**: Gradually replace PowerShell scripts with Python equivalents
4. **Testing**: All scripts must have comprehensive test coverage

### When to Use PowerShell vs Python
**Use PowerShell:**
- Windows-specific system operations
- .NET assembly manipulation and inspection
- Existing working scripts (don't break what's working)
- Azure CLI integration (az commands)
- Windows registry operations

**Use Python:**
- Cross-platform file operations
- HTTP requests and API calls
- Complex data processing and analysis
- Build automation and CI/CD pipelines
- New development tooling and utilities

## ğŸ—ï¸ **Development Environment Architecture**

### Layered Architecture
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  VS Code Tasks (User Interface)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Python Scripts (Primary Tooling)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PowerShell Scripts (Legacy/Windows)â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  .NET CLI / Azure CLI (Foundations) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Build System Strategy
- **dotnet CLI**: Direct use for compilation and publishing
- **Python orchestration**: High-level build coordination
- **PowerShell**: Windows-specific build steps only
- **Azure CLI**: Cloud operations and deployments

### Testing Strategy Enhancement
- **Pester**: PowerShell script testing (maintain existing coverage)
- **pytest**: Python script testing (expand coverage)
- **Integration tests**: Cross-script testing
- **Performance tests**: Profile loading and build times

## ğŸ“Š Benefits of Python Tooling

- **Cross-platform**: Works on Windows, macOS, Linux
- **Maintainable**: Clean, testable Python code
- **Integrated**: Seamless VS Code integration
- **Testable**: Comprehensive test framework with coverage
- **Secure**: Proper environment variable handling
- **Performant**: Optimized for development workflows

## ğŸ”„ Migration from PowerShell

The Python scripts provide enhanced functionality:
- Additional validation and error handling
- Cross-platform compatibility
- Performance optimizations
- Comprehensive logging and monitoring
- Unit test coverage
- Better integration with modern development tools

## ğŸ†˜ Troubleshooting

### Common Issues
- **Environment not loading**: Run `python scripts/load-env.py`
- **Azure connection failed**: Run `python scripts/azure-setup.py --test-connection`
- **Processes not cleaning**: Run `python scripts/cleanup-dotnet.py --force`
- **Tests failing**: Check `pytest.ini` configuration

### Getting Help
- Check `scripts/README.md` for detailed documentation
- Run scripts with `--help` flag for usage information
- Check VS Code task output for detailed error messages

## ğŸ¨ **Theme Management Guidelines**

### SkinManager Implementation - SOLE AUTHORITY

**CRITICAL RULE**: `ThemeUtility` is the **exclusive** theme management system for Wiley Widget. **NO** direct `SfSkinManager` calls are permitted in application code.

#### âœ… **Approved Theme Implementation**

**Only use these methods for theme application:**

```csharp
// âœ… CORRECT - Use ThemeUtility exclusively
using WileyWidget.Services;

ThemeUtility.TryApplyTheme(window, "FluentDark");
ThemeUtility.TryApplyTheme(window, "FluentLight");
ThemeUtility.ApplyCurrentTheme(window);
```

#### âŒ **Forbidden Practices**

```csharp
// âŒ VIOLATION - Direct SfSkinManager calls
SfSkinManager.SetTheme(window, new Theme("FluentDark"));

// âŒ VIOLATION - Custom theme objects
var customTheme = new FluentTheme { /* custom properties */ };
SfSkinManager.SetTheme(window, customTheme);
```

#### **Supported Themes**
- `FluentDark` (default)
- `FluentLight`

#### **Theme Application Pattern**

**All Windows must apply themes using ThemeUtility:**

```csharp
public partial class MyWindow : Window
{
    public MyWindow()
    {
        InitializeComponent();
        
        // âœ… REQUIRED - Apply theme using ThemeUtility
        ThemeUtility.TryApplyTheme(this, SettingsService.Instance.Current.Theme);
    }
}
```

#### **Theme Switching**

**Use ThemeUtility for runtime theme changes:**

```csharp
// âœ… CORRECT - Runtime theme switching
private void OnFluentDarkClick(object sender, RoutedEventArgs e)
{
    ThemeUtility.TryApplyTheme(this, "FluentDark");
    SettingsService.Instance.Current.Theme = "FluentDark";
    SettingsService.Instance.Save();
}
```

#### **Benefits of Centralized Theme Management**

- **Consistency**: All windows use identical theme application logic
- **Error Handling**: Robust fallback to FluentLight on theme failures
- **Normalization**: Automatic theme name canonicalization
- **Logging**: Comprehensive theme application tracking
- **Maintenance**: Single point of change for theme logic

#### **Code Review Checklist**

- [ ] No direct `SfSkinManager.SetTheme()` calls in application code
- [ ] All windows use `ThemeUtility.TryApplyTheme()` in constructors
- [ ] Theme switching uses `ThemeUtility` methods
- [ ] Custom theme objects are not created
- [ ] Theme persistence uses `SettingsService`

#### **Testing Requirements**

- [ ] Theme inheritance tests pass
- [ ] Theme switching functionality verified
- [ ] Fallback behavior tested
- [ ] All windows apply themes consistently

## ğŸ“… **PowerShell â†’ Python Migration Roadmap**

### Phase 1 (Immediate - 2 weeks)
- [ ] Replace Write-Host in all active PowerShell scripts
- [ ] Add PowerShell output standards to guidelines
- [ ] Update VS Code tasks to use Python scripts where possible
- [ ] Audit existing scripts and categorize (keep, migrate, deprecate)

### Phase 2 (Short-term - 1 month)
- [ ] Migrate build.ps1 â†’ build.py (if beneficial)
- [ ] Enhance azure-setup.py to replace azure-setup.ps1
- [ ] Create Python equivalents for high-usage PowerShell scripts
- [ ] Update testing framework to cover both Python and PowerShell

### Phase 3 (Medium-term - 3 months)
- [ ] Deprecate all non-essential PowerShell scripts
- [ ] Update documentation to reflect Python-first approach
- [ ] Train development team on Python development practices
- [ ] Establish Python as the primary scripting language for new features